#' Likelihood that \strong{1} observed spectrum was generated from a vector of expected counts.
#'  
#' Returns the sum of the negative binomial likelihoods
#' that each each element of the
#' spectrum (i.e., the count for each mutation type e.g. ACT > AAT)
#' was generated from expected count for that mutation type.
#'  
#' @param spectrum An observed spectrum (a numeric vector)
#' 
#' @param expected.counts A vector of (integer) expected mutation counts, one
#' expected count for each mutation type. We want to know the 
#' likelihood that this model generated the observed 
#' spectrum, assuming each mutational types generates counts according to
#' a negative binomial distribution with 
#' the given \code{expected.counts} (argument \code{mu}
#' to \code{\link[stats]{NegBinomial}}) and dispersion parameter
#' \code{nbinom.size}.
#' 
#' @param nbinom.size The \code{size} parameter that
#' governs dispersion. See \code{\link[stats]{NegBinomial}}.
#' Smaller values correspond to larger dispersion.
#' 
#' @param verbose If \code{TRUE} print messages under some circumstances.
#'
#' @return \code{log(likelihood(spectrum | expected.counts))}
#' 
#' @importFrom stats dnbinom
#'
#' @keywords internal

LLHSpectrumNegBinom <-
  function(spectrum, expected.counts, nbinom.size, verbose = FALSE) {
  
  stopifnot(length(spectrum) == length(expected.counts))
  loglh <- 0
  for (i in 1:length(spectrum)) { # Iterate over each channel in the
    # spectrum and sum the log
    # likelihoods.
    
    nbinom <- stats::dnbinom(x    = spectrum[i],
                             mu   = expected.counts[i],
                             size = nbinom.size,
                             log  = TRUE)
    
    if (is.nan(nbinom)) {
      warning("nbinom is Nan, changing to -Inf")
      nbinom = -Inf
    }
    if (nbinom == -Inf && verbose) {
      message("nbinom == -Inf for mutation class i = ", i, " (",
              rownames(spectrum)[i],
              ") spectrum[i] = ", spectrum[i], " expected.counts[i] = ",
              expected.counts[i])
    }
    
    loglh <- loglh + nbinom
  }
  stopifnot(mode(loglh) == 'numeric' )
  return(loglh)
}


#' The log likelihood of a \strong{single} observed spectrum given the signature.
#'
#' Assumes that all mutations \code{spectrum} were generated by \code{signature}.
#' 
#' @param spectrum A single background spectrum.
#' 
#' @param signature A signature as a numeric vector.
#' 
#' @param nbinom.size The \code{size} argument for
#' \code{\link[stats]{NegBinomial}}.
#' 
#' @keywords internal
#' 
LLHOfSignatureGivenSpectrum <- function(spectrum, signature, nbinom.size) {
    expected.counts <- sum(spectrum) * signature
    LLH <- LLHSpectrumNegBinom(spectrum, expected.counts, nbinom.size)
    return(LLH)
  }


#' Objective function for estimating a background signature from multiple background spectra.
#' 
#' Returns the negative log likelihood
#' that the signature with an
#' estimated negative binomial
#' dispersion parameter,
#' generated the observed (multiple) spectra given the
#' likelihood of the observed total counts
#' attributed to the signature.
#' 
#' @keywords internal
#' 
#' @param sig.and.nbinom.size Concatenation of signature as a vector and
#' the negative binomial dispersion parameter.
#' 
#' @param spectra The observed spectra as an \code{\link[ICAMS]{ICAMS}}
#' \code{catalog}.
#' 
#' @return -1 * the log likelihood that the the input signature,
#' dispersion parameter, and mutation count generated 
#' the observed spectrum

NegLLHOfSignature <- function(sig.and.nbinom.size, spectra) {
  len <- length(sig.and.nbinom.size)
  nbinom.size <- sig.and.nbinom.size[len]
  sig         <- sig.and.nbinom.size[-len]
  loglh <- 0
  for (i in 1:ncol(spectra)) {
    loglh.i <-
      LLHOfSignatureGivenSpectrum(spectra[ , i, drop = FALSE],
                                  sig,
                                  nbinom.size)
    loglh <- loglh + loglh.i
  }
  
  return(-1 * loglh)   
}


#' Estimate a signature from experimentally exposed spectra minus a background signature.
#' 
#' @description 
#'
#' We index mutation channels (e.g. \code{ACA > AAA, ACC > AAC, ...}) by \eqn{j}, \eqn{j \in 1...96}.
#' 
#' We index input mutational spectra by \eqn{i}. 
#'
#' Let
#'  
#' \eqn{g = g_1, g_2,\ldots , g_{96}}, with \eqn{\Sigma g_j = 1},
#'  be the previously determined, input background signature profile,
#' 
#' \eqn{s^i, i \in 1, 2,\ldots} be the input spectra,
#' from exposed samples, usually only 2 or 3,
#' 
#' \eqn{b^i, i \in 1, 2,\ldots} be the (to-be-estimated)
#' numbers of mutations due to the background signature in each
#' \eqn{s^i}, and
#' 
#' \eqn{t = t_1, t_2,\ldots , t_{96}}, with \eqn{\Sigma t_j = 1},
#' be the (to-be-estimated) target signature due to an exposure.
#' 
#' We want to maximize \eqn{\Pi^iP(s^i|b^i,t)P(b^i)} over 
#' \eqn{b^1, b^2,\dots} and \eqn{t}.  (Note that the code
#' actually minimizes the additive inverse of this.)
#' 
#' \eqn{P(b^i)} is estimated from the distribution of previously observed
#' numbers of mutations in untreated samples, with the additional 
#' constraint that \eqn{b^i \le |s^i|}), where \eqn{|s^i|} is defined as
#' the total number of mutations in spectrum \eqn{s^i}, i.e.
#' \eqn{|s^i| = \Sigma_j s^i_j}, \eqn{j \in 1...96}.
#' 
#' \eqn{P(s^i|b^i,t)} is estimated as follows:
#' 
#' The expected number of mutations in each
#' mutation category, \eqn{j}, is estimated as
#' 
#' \eqn{e^i_j = g_jb^i + t_j(|s^i| - b^i)}.
#' 
#' Then \eqn{P(s^i|e^i)} is estimated as \eqn{\Pi_jP(s^i_j|e^i_j)}.
#' 
#' \eqn{P(s^i_j|e^i_j)} is estimated from a negative binomial distribution
#' centered on each \eqn{e^i_j}; these distributions all
#' have a dispersion parameter
#' of 10 (hard coded in \code{\link{ObjFn1}}), a value chosen based on tests with 
#' synthetic data. 
#' 
#' @param spectra The spectra from which to subtract the background,
#'   as a matrix or \code{\link[ICAMS]{ICAMS}} catalog.
#'   
#' @param bg.sig.info Information about the background signature. See for example
#'   \code{\link{HepG2.background.info}}.
#'   
#' @param m.opts Options to pass to \code{\link[nloptr]{nloptr}}.
#' 
#' @param start.b.fraction The estimated fraction of the mutations in
#'   \code{spectra} due to the background signature.
#' 
#' @details
#' See \code{\link{ObjFn1}}.
#' 
# Ignore this note: I guess you could estimate "background" and "target.sig"
# at the same time, but then background might be slightly (?)
# different for each set of input spectra. To do that would
# include the likelihoods
# background.s1 | background.sig, background.sig.nbinom.size
# background.s2 | background.sig, background.sig.nbinom.size
# and include a maximization over background.sig and
# background.sig.nbinom.size
# ....
# 
#' @export

SeparateSignatureFromBackground <-
  function(spectra,
           bg.sig.info,
           m.opts = NULL,
           start.b.fraction = 0.1) {
    
    if (is.null(m.opts)) m.opts <- SeparateSignatureFromBackgroundOptions()
    
    spectra.catalog.type <- attr(spectra, "catalog.type", exact = TRUE)
    stopifnot(!is.null(spectra.catalog.type))
    sig0 <- MeanOfSpectraAsSig(spectra)
    
    b.x0 <- start.b.fraction * colSums(spectra)
    est.target.sig.and.b.x0 <- c(sig0, b.x0)
    
    # Each element of the singature <= 1.
    upper.bounds.of.target.sig <- rep(1, nrow(spectra))
    
    ret <- nloptr::nloptr(
      x0          = est.target.sig.and.b.x0,
      
      eval_f      = ObjFn1,
      
      lb          = rep(0, length(est.target.sig.and.b.x0)),
      
      ub          = c(upper.bounds.of.target.sig, 
                      
                      colSums(spectra) # The contribution of the background
                                       # should not exceed the total count
                                       # of the spectrum
                      ),
      opt = m.opts,
      obs.spectra = spectra,     
      bg.sig.info = bg.sig.info)
    
    soln <- ret$solution
    
    bg.exposure <- soln[(1 + nrow(spectra)):length(soln)]
    obs.counts  <- colSums(spectra)
    
    return(list(inferred.target.sig     = soln[1:nrow(spectra)],
                exposures.to.target.sig = obs.counts - bg.exposure,
                exposures.to.bg.sig     = bg.exposure,
                message                 = ret$message,
                all.opt.ret             = ret))
  }


#' Objective function for \code{\link{SeparateSignatureFromBackground}}.
#' 
#' @param est.target.sig.and.b A numeric vector of which elements
#' 1:96 are the signature (as a vector) and the remaining elements
#' are the coefficients for each input spectrum in \code{obs.spectra}.
#' 
#' @param obs.spectra The observed spectra, which may be the
#' sum of the activities of the background signature and the signature
#' of an experimental treatment.
#' 
#' @param bg.sig.info Information on the background signature. See for example
#' \code{\link{HepG2.background.info}}.
#' 
#' We the caller will seek to minimize the value of this function.
#' 
#' @keywords internal
#' 
ObjFn1 <- function(
  est.target.sig.and.b, # Parameters to optimize
  obs.spectra,     
  bg.sig.info   # E.g. HepG2.background.info
) {
  bg.sig.profile <- bg.sig.info$background.sig
  stopifnot(!is.null(bg.sig.profile))
  stopifnot("matrix" %in% class(bg.sig.profile))
  len.sig <- nrow(bg.sig.profile)
  est.target.sig <- est.target.sig.and.b[1:len.sig]
  
  b <- est.target.sig.and.b[(1 + len.sig):length(est.target.sig.and.b)]
  # b is a vector of the number of mutations contributed
  # by the background to each spectrum

  loglh <- 0
  for (i in 1:ncol(obs.spectra)) { # For each observed spectrum
    obs.spectrum <- obs.spectra[ , i, drop = FALSE]
    total.obs.count <- sum(obs.spectrum)
    expected.bg.counts <- bg.sig.profile * b[i]
    expected.counts <- 
      expected.bg.counts + (est.target.sig * (total.obs.count - b[i]))
    if (FALSE) { # Experimental code, if enabled, does not converge
                 # (or converges very slowly).
      bg.greater.than.spectrum <- which(expected.bg.counts > obs.spectrum)
      if (length(bg.greater.than.spectrum) > 0) {
        message("x")
        return(Inf)
      } }
    loglh1.i <- LLHSpectrumNegBinom(
      spectrum        = obs.spectrum,
      expected.counts = expected.counts,
      nbinom.size     = 10)  # This is the dispersion parameter for each channel
 
    loglh2.i <- dnbinom(x    = round(b[i]), 
                        mu   = bg.sig.info$count.nbinom.mu,
                        size = bg.sig.info$count.nbinom.size, # This is the dispersion paramater for the number of background signature mutations
                        log  = TRUE)
    
    loglh <- loglh + loglh1.i + loglh2.i
  }
  
  return(-1 * loglh)
}

#' Return the mean of multiple spectra as a signature.
#' 
#' @param spectra Convert each spectrum to a signature and then compute the
#'   mean of all signatures.
#'   
#' @export
#' 
MeanOfSpectraAsSig <- function(spectra) {
  
  if (is.null(spectra)) {
    stop("Input argument of MeanOfSpetra is NULL")
  }
  
  ctype <- attr(spectra, "catalog.type", exact = TRUE)
  
  if (is.null(ctype)) {
    stop("Cannot call MeanOfSpectraAsSig when catalog.type is NULL")
  } else if (ctype == "counts") {
    tctype <- "counts.signature"
  } else if (ctype == "density") {
    tctype <- "density.signature"
  } else {
    stop("Cannot call MeanOfSpectraAsSig when catalog.type is ", ctype)
  }
  
  target.abundance <- attr(spectra, "abundance", exact = TRUE)

  stopifnot(!is.null(target.abundance))

  sigs <- ICAMS::TransformCatalog(spectra, 
                                  target.catalog.type = tctype,
                                  target.abundance = target.abundance)
  
  mean.sig <- apply(X = sigs, MARGIN = 1, mean)

  mean.sig <- matrix(mean.sig, ncol = 1)
  
  mean.sig <- 
    ICAMS::as.catalog(mean.sig, 
                      catalog.type = tctype, 
                      region = "genome", 
                      infer.rownames = TRUE)
  
  colnames(mean.sig) <- "mean.spectra.based.sig"
  
  return(mean.sig)
}


Solution2SigVec <- function(solution, sig.number = 96) {
  sig.vec <- solution[1:sig.number]
  return(sig.vec / sum(sig.vec))
}


Solution2Signature <- function(solution, 
                                sig.number = 96,
                                ref.genome = NULL,
                                region = "genome") {
  sig <- matrix(Solution2SigVec(solution), ncol = 1)
  rownames(sig) <- ICAMS::catalog.row.order[["SBS96"]]
  colnames(sig) <- "Inferred.sig"
  sig <- ICAMS::as.catalog(
    sig, ref.genome = ref.genome,
    region = region,
    catalog.type = "counts.signature"
  )
  return(sig)
}


Nloptr2BGMutationCounts <- function(nloptr.retval, sig.number = 96) {
  solution <- nloptr.retval$solution
  return(solution[(sig.number + 1):length(solution)])
}


Nloptr2Signature <- function(nloptr.retval, sig.number = 96) {
  return(Solution2Signature(nloptr.retval$solution, sig.number))
}

#' Return a default value to pass as the \code{m.opts} argument to \code{\link{SeparateSignatureFromBackground}}.
SeparateSignatureFromBackgroundOptions <- function() {
  return(
    list(algorithm = "NLOPT_LN_COBYLA",
         maxeval = 10000, 
         print_level = 0,
         xtol_rel = 0.0001,  # 0.0001,)
         xtol_abs = 1e-06
         )
  )
}
