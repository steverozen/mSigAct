#' Show signature activity from the output generated by \code{AddSigActivity}
#'
#' @param list.of.sig.activity A list of contributing signature activity
#'   information for multiple spectra. See the return value of
#'   \code{\link{AddSigActivity}} for more details.
#' 
#' @param output.dir The directory to save the results. Create
#'   this directory if it does not exist.
#'   
#' @param plot.all.samples.in.one.pdf Whether to plot all the signature activity information
#'   within one PDF. Default is TRUE. If FALSE, then plot one PDF for each sample.
#' 
#' @param plot.exposure.proportion Whether to plot exposure proportions rather
#'   than counts.
#' 
#' @param ... Other arguments passed to \code{\link[ICAMS]{PlotCatalogToPdf}}.
#' 
#' @export
#'
#' @examples
#' spectra <- PCAWG7::spectra$PCAWG$SBS96[, 1:2, drop = FALSE]
#' exposure <- PCAWG7::exposure$PCAWG$SBS96[, 1:2, drop = FALSE]
#' sigs <- PCAWG7::COSMIC.v3.1$signature$genome$SBS96
#' sigs.prop <- ExposureProportions(mutation.type = "SBS96", 
#'                                  cancer.type = "Biliary-AdenoCA")
#' retval <- AddSigActivity(spectra, exposure, sigs, sigs.prop)
#' ShowSigActivity(retval, output.dir = file.path(tempdir(), "SBS96"))
ShowSigActivity <- function(list.of.sig.activity,
                            output.dir,
                            plot.all.samples.in.one.pdf = TRUE, 
                            plot.exposure.proportion = FALSE,
                            ...) {
  if (!dir.exists(output.dir)) {
    dir.create(output.dir)
  }
  
  mut.type <- GetMutationType(list.of.sig.activity[[1]][[1]])
  
  WriteDistances(list.of.sig.activity = list.of.sig.activity, 
                 output.dir = output.dir, mutation.type = mut.type)
  PlotSigActivityToPdf(list.of.sig.activity = list.of.sig.activity, 
                       output.dir = output.dir,
                       mutation.type = mut.type,
                       plot.all.samples.in.one.pdf = plot.all.samples.in.one.pdf, 
                       ... = ...)
  ShowExposure(list.of.sig.activity = list.of.sig.activity, 
               output.dir = output.dir, mutation.type = mut.type,
               plot.exposure.proportion = plot.exposure.proportion)
  
}

#' Show signature exposure from the output generated by \code{AddSigActivity}
#'
#' @inheritParams ShowSigActivity
#' 
#' @param mutation.type The mutation type of the mutational spectrum.
#' 
#' @keywords internal
ShowExposure <- function(list.of.sig.activity, output.dir, mutation.type,
                         plot.exposure.proportion = FALSE) {
  # Retrieve the exposure information
  exposure.info <- lapply(list.of.sig.activity, FUN = function(x) {
    spect <- x$original.spect
    return(attr(spect, "exposure"))
  })
  
  exposure <- do.call(cbind, exposure.info)
  
  # Remove rows with zero exposure
  exposure <- exposure[rowSums(exposure) > 0, , drop = FALSE]
  
  if (isTRUE(plot.exposure.proportion)) {
    output.file <- 
      file.path(output.dir, paste0(mutation.type, ".all.samples.exposure.props.pdf"))
  } else {
    output.file <- 
      file.path(output.dir, paste0(mutation.type, ".all.samples.exposure.counts.pdf"))
  }
  
  ICAMSxtra::PlotExposureToPdf(exposure = exposure, file = output.file,
                               plot.proportion = plot.exposure.proportion)
  
}

#' Write distances from the output generated by \code{AddSigActivity}
#'
#' @inheritParams ShowSigActivity
#' 
#' @param mutation.type The mutation type of the mutational spectrum.
#'
#' @keywords internal
WriteDistances <- function(list.of.sig.activity, output.dir, mutation.type) {
  if (!dir.exists(output.dir)) {
    dir.create(output.dir)
  }
  
  # Retrieve the distances information
  distances.info <- lapply(list.of.sig.activity, FUN = function(x) {
    distances <- x$distances
    values <- matrix(distances$value, ncol = nrow(distances))
    colnames(values) <- distances$method
    return(as.data.frame(values))
  })
  
  retval <- do.call(dplyr::bind_rows, distances.info)
  rownames(retval) <- names(list.of.sig.activity)
  
  output.file <- 
    file.path(output.dir, paste0(mutation.type, ".all.samples.distances.csv"))
  write.csv(retval, file = output.file)
  
}

#' Plot signature activity from the output generated by \code{AddSigActivity} to PDF
#'
#' @inheritParams ShowSigActivity
#' 
#' @param mutation.type The mutation type of the mutational spectrum.
#' 
#' @return An \strong{invisible} list whose first element is a logic value
#'   indicating whether the plot is successful. 
#'
#' @keywords internal
PlotSigActivityToPdf <- function(list.of.sig.activity, 
                                 output.dir,
                                 mutation.type,
                                 plot.all.samples.in.one.pdf = TRUE, 
                                 ...) {
  if (!dir.exists(output.dir)) {
    dir.create(output.dir)
  }
  
  # Remove the distances information
  list.of.sig.activity <- lapply(list.of.sig.activity, FUN = function(x) {
    x$distances <- NULL
    return(x)
  })
  
  if (plot.all.samples.in.one.pdf) {
    old.par.tck.value <- graphics::par("tck")
    file <- 
      file.path(output.dir, paste0(mutation.type, ".all.samples.sig.activity.pdf"))
    
    # Setting the width and length for A4 size plotting
    grDevices::pdf(file, width = 8.2677, height = 11.6929, onefile = TRUE)
    graphics::par(tck = old.par.tck.value)
    
    num.of.samples <- length(list.of.sig.activity)
    mut.type <- GetMutationType(list.of.sig.activity[[1]][[1]])
    if (nrow(list.of.sig.activity[[1]][[1]]) == 96) {
      opar <- graphics::par(mfrow = c(8, 1), mar = c(4, 5.5, 2, 1), 
                            oma = c(1, 1, 2, 1))
    } else if (nrow(list.of.sig.activity[[1]][[1]]) == 192) {
      opar <- graphics::par(mfrow = c(8, 1), mar = c(2, 4, 2, 2), 
                            oma = c(3, 2, 1, 1))
    } else if (nrow(list.of.sig.activity[[1]][[1]]) == 78) {
      opar <- graphics::par(mfrow = c(8, 1), mar = c(2, 4, 2, 2), 
                            oma = c(3, 3, 2, 2))
    } else if (nrow(list.of.sig.activity[[1]][[1]]) == 83) {
      opar <- graphics::par(mfrow = c(8, 1), mar = c(3, 4, 2.5, 2), 
                            oma = c(3, 3, 2, 2))
    } 
    
    on.exit(graphics::par(opar))
    for (sample in 1:num.of.samples) {
      list.of.catalogs <- list.of.sig.activity[[sample]]
      num.of.catalogs <- length(list.of.catalogs)
      num.of.plots <- sum(sapply(list.of.catalogs, FUN = ncol))
      
      for (i in 1:num.of.catalogs) {
        catalog <- list.of.catalogs[[i]]
        num.of.samples <- ncol(catalog)
        
        for (j in 1:num.of.samples) {
          cat <- catalog[, j, drop = FALSE]
          ICAMS::PlotCatalog(cat, ... = ...)
        }
      }
      
      # Make sure the plotting of each sample starts on a new page
      num.of.plot.on.last.page <- num.of.plots %% 8
      if (num.of.plot.on.last.page != 0) {
        num.of.empty.plots <- 8 - num.of.plot.on.last.page
        for (i in 1:num.of.empty.plots) {
          graphics::plot.new()
        }
      }
    }
    grDevices::dev.off()
    invisible(list(plot.success = TRUE))
  } else {
    for (sample in names(list.of.sig.activity)) {
      
      # We cannot use "::" in the file path, otherwise grDevices::pdf will throw an error
      spect.name <- gsub(pattern = "::", replacement = ".", sample)
      output.file <- 
        file.path(output.dir, paste0(mutation.type, ".", 
                                     spect.name, ".sig.activity.pdf"))
      PlotListOfCatalogsToPdf(list.of.catalogs = list.of.sig.activity[[sample]],
                              file = output.file, ... = ...)
    }
    invisible(list(plot.success = TRUE))
  }
}